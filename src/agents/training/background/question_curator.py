"""Question Curator - Ranks and batches expert questions for user review.

Manages the queue of questions generated by PatternAnalyzerAgent:
- Ranks questions by pedagogical value
- Batches questions for daily delivery
- Tracks answered vs unanswered questions
- Provides progress statistics
"""

from __future__ import annotations

import json
import logging
from dataclasses import asdict, dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

from agents.training.background.pattern_analyzer import ExpertQuestion

logger = logging.getLogger(__name__)


@dataclass
class QuestionBatch:
    """A batch of questions for daily review."""

    batch_id: str  # YYYYMMDD format
    questions: list[ExpertQuestion]
    created_at: str
    answered_count: int = 0
    skipped_count: int = 0

    def to_dict(self) -> dict[str, Any]:
        return {
            "batch_id": self.batch_id,
            "questions": [q.to_dict() for q in self.questions],
            "created_at": self.created_at,
            "answered_count": self.answered_count,
            "skipped_count": self.skipped_count,
        }

    @property
    def total_count(self) -> int:
        return len(self.questions)

    @property
    def pending_count(self) -> int:
        return self.total_count - self.answered_count - self.skipped_count

    @property
    def completion_rate(self) -> float:
        """Percentage of questions answered or skipped."""
        if self.total_count == 0:
            return 0.0
        return (self.answered_count + self.skipped_count) / self.total_count


@dataclass
class AnsweredQuestion:
    """A question that has been answered by the user."""

    question: ExpertQuestion
    answer: str
    answered_at: str
    answer_word_count: int
    converted_to_samples: bool = False
    sample_count: int = 0

    def to_dict(self) -> dict[str, Any]:
        return {
            "question": self.question.to_dict(),
            "answer": self.answer,
            "answered_at": self.answered_at,
            "answer_word_count": self.answer_word_count,
            "converted_to_samples": self.converted_to_samples,
            "sample_count": self.sample_count,
        }


class QuestionCurator:
    """Manages expert question ranking and batching.

    Workflow:
    1. Load questions from PatternAnalyzer database
    2. Rank by pedagogical value and priority
    3. Create daily batches of N questions
    4. Track answered/skipped questions
    5. Provide progress statistics
    """

    def __init__(self, context_root: Optional[Path] = None):
        """Initialize question curator.

        Args:
            context_root: Root directory for context storage (default: ~/.context)
        """
        if context_root is None:
            context_root = Path.home() / ".context"

        self.context_root = context_root
        self.training_dir = context_root / "training"
        self.training_dir.mkdir(parents=True, exist_ok=True)

        # Databases
        self.questions_db = self.training_dir / "expert_questions.json"
        self.batches_db = self.training_dir / "question_batches.json"
        self.answered_db = self.training_dir / "answered_questions.json"
        self.skipped_db = self.training_dir / "skipped_questions.json"

    def load_all_questions(self) -> list[ExpertQuestion]:
        """Load all questions from database."""
        if not self.questions_db.exists():
            logger.warning(f"Questions DB not found: {self.questions_db}")
            return []

        with open(self.questions_db) as f:
            data = json.load(f)

        from agents.training.background.pattern_analyzer import CodePattern

        questions = []
        for q_data in data:
            pattern_data = q_data["pattern"]
            pattern = CodePattern(**pattern_data)

            question = ExpertQuestion(
                question_id=q_data["question_id"],
                pattern=pattern,
                question_text=q_data["question_text"],
                question_type=q_data["question_type"],
                difficulty=q_data["difficulty"],
                learning_objectives=q_data["learning_objectives"],
                estimated_answer_length=q_data["estimated_answer_length"],
                priority_score=q_data["priority_score"],
            )
            questions.append(question)

        return questions

    def load_answered_questions(self) -> list[AnsweredQuestion]:
        """Load answered questions from database."""
        if not self.answered_db.exists():
            return []

        with open(self.answered_db) as f:
            data = json.load(f)

        from agents.training.background.pattern_analyzer import CodePattern

        answered = []
        for a_data in data:
            pattern_data = a_data["question"]["pattern"]
            pattern = CodePattern(**pattern_data)

            q_data = a_data["question"]
            question = ExpertQuestion(
                question_id=q_data["question_id"],
                pattern=pattern,
                question_text=q_data["question_text"],
                question_type=q_data["question_type"],
                difficulty=q_data["difficulty"],
                learning_objectives=q_data["learning_objectives"],
                estimated_answer_length=q_data["estimated_answer_length"],
                priority_score=q_data["priority_score"],
            )

            answered_q = AnsweredQuestion(
                question=question,
                answer=a_data["answer"],
                answered_at=a_data["answered_at"],
                answer_word_count=a_data["answer_word_count"],
                converted_to_samples=a_data.get("converted_to_samples", False),
                sample_count=a_data.get("sample_count", 0),
            )
            answered.append(answered_q)

        return answered

    def load_skipped_questions(self) -> set[str]:
        """Load skipped question IDs."""
        if not self.skipped_db.exists():
            return set()

        with open(self.skipped_db) as f:
            data = json.load(f)

        return set(data.get("skipped_ids", []))

    def rank_questions(
        self,
        questions: list[ExpertQuestion],
        novelty_weight: float = 0.4,
        priority_weight: float = 0.3,
        difficulty_weight: float = 0.3,
    ) -> list[ExpertQuestion]:
        """Rank questions by pedagogical value.

        Args:
            questions: Questions to rank
            novelty_weight: Weight for question novelty (not answered yet)
            priority_weight: Weight for intrinsic priority score
            difficulty_weight: Weight for difficulty level

        Returns:
            Sorted questions (highest score first)
        """
        # Get already answered question IDs
        answered = self.load_answered_questions()
        answered_ids = {aq.question.question_id for aq in answered}

        # Score each question
        scored = []
        for q in questions:
            # Novelty score: 1.0 if not answered, 0.0 if answered
            novelty = 1.0 if q.question_id not in answered_ids else 0.0

            # Difficulty score: advanced > intermediate > beginner
            difficulty_map = {"beginner": 0.3, "intermediate": 0.6, "advanced": 1.0}
            difficulty = difficulty_map.get(q.difficulty, 0.5)

            # Combined score
            score = (
                novelty_weight * novelty
                + priority_weight * q.priority_score
                + difficulty_weight * difficulty
            )

            scored.append((score, q))

        # Sort by score descending
        scored.sort(key=lambda x: x[0], reverse=True)
        return [q for score, q in scored]

    def create_batch(
        self,
        batch_size: int = 7,
        batch_id: Optional[str] = None,
    ) -> Optional[QuestionBatch]:
        """Create a new batch of questions for review.

        Args:
            batch_size: Number of questions per batch
            batch_id: Batch ID (default: today's date YYYYMMDD)

        Returns:
            QuestionBatch or None if no questions available
        """
        # Load and rank questions
        all_questions = self.load_all_questions()
        if not all_questions:
            logger.warning("No questions available for batching")
            return None

        ranked = self.rank_questions(all_questions)

        # Get already answered/skipped questions
        answered = self.load_answered_questions()
        answered_ids = {aq.question.question_id for aq in answered}
        skipped_ids = self.load_skipped_questions()

        # Filter out answered/skipped questions
        pending = [
            q
            for q in ranked
            if q.question_id not in answered_ids and q.question_id not in skipped_ids
        ]

        if not pending:
            logger.info("No pending questions - all answered or skipped")
            return None

        # Take top N questions
        batch_questions = pending[:batch_size]

        # Generate batch ID
        if batch_id is None:
            batch_id = datetime.now().strftime("%Y%m%d")

        batch = QuestionBatch(
            batch_id=batch_id,
            questions=batch_questions,
            created_at=datetime.now().isoformat(),
        )

        # Save batch
        self._save_batch(batch)

        logger.info(f"Created batch {batch_id} with {len(batch_questions)} questions")
        return batch

    def _save_batch(self, batch: QuestionBatch) -> None:
        """Save batch to database."""
        # Load existing batches
        batches = []
        if self.batches_db.exists():
            with open(self.batches_db) as f:
                batches = json.load(f)

        # Add or update batch
        batch_dict = batch.to_dict()
        existing_idx = next(
            (i for i, b in enumerate(batches) if b["batch_id"] == batch.batch_id),
            None,
        )

        if existing_idx is not None:
            batches[existing_idx] = batch_dict
        else:
            batches.append(batch_dict)

        # Save
        with open(self.batches_db, "w") as f:
            json.dump(batches, f, indent=2)

    def get_batch(self, batch_id: str) -> Optional[QuestionBatch]:
        """Get a specific batch by ID."""
        if not self.batches_db.exists():
            return None

        with open(self.batches_db) as f:
            batches = json.load(f)

        batch_data = next((b for b in batches if b["batch_id"] == batch_id), None)
        if not batch_data:
            return None

        # Reconstruct batch
        from agents.training.background.pattern_analyzer import CodePattern

        questions = []
        for q_data in batch_data["questions"]:
            pattern_data = q_data["pattern"]
            pattern = CodePattern(**pattern_data)

            question = ExpertQuestion(
                question_id=q_data["question_id"],
                pattern=pattern,
                question_text=q_data["question_text"],
                question_type=q_data["question_type"],
                difficulty=q_data["difficulty"],
                learning_objectives=q_data["learning_objectives"],
                estimated_answer_length=q_data["estimated_answer_length"],
                priority_score=q_data["priority_score"],
            )
            questions.append(question)

        return QuestionBatch(
            batch_id=batch_data["batch_id"],
            questions=questions,
            created_at=batch_data["created_at"],
            answered_count=batch_data.get("answered_count", 0),
            skipped_count=batch_data.get("skipped_count", 0),
        )

    def get_today_batch(self) -> Optional[QuestionBatch]:
        """Get today's batch (or create if it doesn't exist)."""
        today_id = datetime.now().strftime("%Y%m%d")
        batch = self.get_batch(today_id)

        if batch is None:
            batch = self.create_batch(batch_id=today_id)

        return batch

    def answer_question(
        self,
        question_id: str,
        answer: str,
    ) -> AnsweredQuestion:
        """Mark a question as answered and save the answer.

        Args:
            question_id: Question ID
            answer: User's answer

        Returns:
            AnsweredQuestion record
        """
        # Find question
        all_questions = self.load_all_questions()
        question = next((q for q in all_questions if q.question_id == question_id), None)

        if not question:
            raise ValueError(f"Question not found: {question_id}")

        # Create answered record
        answered = AnsweredQuestion(
            question=question,
            answer=answer,
            answered_at=datetime.now().isoformat(),
            answer_word_count=len(answer.split()),
        )

        # Save to answered database
        existing = []
        if self.answered_db.exists():
            with open(self.answered_db) as f:
                existing = json.load(f)

        existing.append(answered.to_dict())

        with open(self.answered_db, "w") as f:
            json.dump(existing, f, indent=2)

        logger.info(f"Saved answer for question: {question_id}")
        return answered

    def skip_question(self, question_id: str) -> None:
        """Mark a question as skipped."""
        skipped_ids = self.load_skipped_questions()
        skipped_ids.add(question_id)

        with open(self.skipped_db, "w") as f:
            json.dump({"skipped_ids": list(skipped_ids)}, f, indent=2)

        logger.info(f"Skipped question: {question_id}")

    def get_statistics(self) -> dict[str, Any]:
        """Get Q&A statistics.

        Returns:
            Dictionary with:
            - total_questions: Total questions in database
            - answered_count: Questions answered
            - skipped_count: Questions skipped
            - pending_count: Questions not yet reviewed
            - answer_word_count_avg: Average answer length
            - conversion_rate: % of answers converted to samples
        """
        all_questions = self.load_all_questions()
        answered = self.load_answered_questions()
        skipped_ids = self.load_skipped_questions()

        total_questions = len(all_questions)
        answered_count = len(answered)
        skipped_count = len(skipped_ids)
        pending_count = total_questions - answered_count - skipped_count

        # Answer word count
        if answered:
            avg_word_count = sum(a.answer_word_count for a in answered) / len(answered)
        else:
            avg_word_count = 0

        # Conversion rate
        converted = [a for a in answered if a.converted_to_samples]
        conversion_rate = len(converted) / len(answered) if answered else 0.0

        # Total samples generated
        total_samples = sum(a.sample_count for a in answered)

        return {
            "total_questions": total_questions,
            "answered_count": answered_count,
            "skipped_count": skipped_count,
            "pending_count": pending_count,
            "answer_word_count_avg": avg_word_count,
            "conversion_rate": conversion_rate,
            "total_samples_generated": total_samples,
        }
